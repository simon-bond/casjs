// Generated by CoffeeScript 1.7.1
(function() {
  cas.StrikingDisplay = (function() {
    StrikingDisplay.prototype.SPEED_WIDTH = 200;

    StrikingDisplay.prototype.CORRECT_LINE_COLOUR = "rgb(0,150,255)";

    StrikingDisplay.prototype.GRID_COLOUR = "rgb(150,150,150)";

    StrikingDisplay.prototype.LIGHTGRAY = "rgb(211, 211, 211)";

    StrikingDisplay.prototype.BACKGROUND_HAND = "rgb(242,242,242)";

    StrikingDisplay.prototype.BACKGROUND_BACK = "rgb(230,230,230)";

    StrikingDisplay.prototype.BACKGROUND_HANDBAD = "rgb(245,220,220)";

    StrikingDisplay.prototype.BACKGROUND_BACKBAD = "rgb(230,207,207)";

    StrikingDisplay.prototype.BACKGROUND_HANDGOOD = "rgb(230,245,230)";

    StrikingDisplay.prototype.BACKGROUND_BACKGOOD = "rgb(216,230,216)";

    function StrikingDisplay() {
      var fInterbellGap;
      this.fRowsLoaded = false;
      this.fInChangesOnly = true;
      this.fAdvancedView = true;
      this.fWidthPerBell = 100;
      this.fHeightPerRow = 20;
      this.fTitleFontHeight = 12;
      this.fSmallFontHeight = 12;
      this.fCharWidth = 3;
      this.fThisActualX = [];
      this.fThisCorrectX = [];
      this.fLastPlace = [];
      this.fLastActualX = [];
      this.fLastCorrectX = [];
      this.fRowLeft = 0;
      this.fRowRight = 0;
      fInterbellGap = 0;
      this.fInChanges = false;
      this.fHighlightedBell = 9;
      this.canvas = document.getElementById('gridCanvas');
      this.context = this.canvas.getContext('2d');
    }

    StrikingDisplay.prototype.loadRows = function(data) {
      if (data.getNBells() === 0) {
        return null;
      }
      this.fWidthPerBell = Math.round(400 / data.getNBells());
      this.fData = data;
      this.fRowsLoaded = true;
      if (this.measureUp()) {
        return this.paintCanvas();
      }
    };

    StrikingDisplay.prototype.measureUp = function() {
      var maxDuration, minDuration;
      if (!this.fRowsLoaded) {
        return false;
      }
      minDuration = this.fData.getMinDuration(false);
      maxDuration = this.fData.getMaxDuration(false);
      this.fAvBackDuration = (minDuration.back + maxDuration.back) / 2;
      this.fMinDur = Math.min(minDuration.hand, minDuration.back);
      this.fMaxMinusMinDur = Math.max(1, Math.max(maxDuration.hand, maxDuration.back) - this.fMinDur);
      this.fPixelsPerMs = (this.fWidthPerBell * this.fData.getNBells()) / this.fAvBackDuration;
      this.fY0 = 20 + this.fHeightPerRow;
      this.fRowRight = this.fWidthPerBell * 2 + this.fWidthPerBell * this.fData.getNBells();
      return true;
    };

    StrikingDisplay.prototype.paintCanvas = function() {
      var i, r, y, _i, _j, _k, _ref, _ref1, _ref2, _results;
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      for (i = _i = 0, _ref = this.fData.getNBells(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.fLastActualX[i] = -1;
        this.fLastCorrectX[i] = -1;
      }
      this.fInChanges = false;
      this.renderColumnHeadings();
      this.context.strokeStyle = 'black';
      y = this.fY0;
      for (i = _j = 0, _ref1 = this.fData.getNRows(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        r = this.fData.getRow(i);
        if (r != null) {
          this.calcEffectivePixelsPerMs(r);
          this.fRowLeft = this.fRowRight - Math.round(r.getRowDuration() * this.fEffectivePixelsPerMs);
          this.fInterbellGap = Math.round(r.getAveragedGap() * this.fEffectivePixelsPerMs);
          this.drawRowBackground(y, r, i, i > 0 ? this.fData.getRow(i - 1) : null);
          this.annotateRows(y, r, i);
          this.drawLines(y, r);
        }
        y += this.fHeightPerRow;
      }
      y = this.fY0;
      _results = [];
      for (i = _k = 0, _ref2 = this.fData.getNRows(); 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        r = this.fData.getRow(i);
        if (r != null) {
          this.calcEffectivePixelsPerMs(r);
          this.drawBellNumbers(y, r, i);
        }
        _results.push(y += this.fHeightPerRow);
      }
      return _results;
    };

    StrikingDisplay.prototype.renderColumnHeadings = function() {
      this.context.fillStyle = 'blue';
      this.context.font = this.fTitleFontHeight.toString() + "px serif";
      this.context.fillText("Row", 1, this.fTitleFontHeight);
      this.context.fillText("Striking Graph", this.fRowLeft + (this.fRowRight - this.fRowLeft) / 2 - 20, this.fTitleFontHeight);
      return this.context.fillText("Row Length Graph", this.fRowRight + this.fInterbellGap + 10, this.fTitleFontHeight);
    };

    StrikingDisplay.prototype.annotateRows = function(y, row, i) {
      var x, xAG;
      this.context.fillStyle = 'black';
      if (!row.isHandstroke()) {
        this.context.fillText("" + (i + 1), 0, y);
      }
      if (this.fAdvancedView && i % 10 === 0) {
        y -= this.fHeightPerRow / 2;
        x = this.fRowRight + this.fInterbellGap + 20;
        this.context.fillText("" + Math.round(row.getRowDuration()) + "ms", x, y + this.fTitleFontHeight / 3);
        this.context.fillText("" + Math.round(row.getAveragedGap() * row.getHandstrokeGap()), this.fRowLeft, y);
        this.context.fillText(" ms", this.fRowLeft, y + this.fSmallFontHeight);
        xAG = this.fRowRight + this.fInterbellGap100;
        this.context.fillText("" + Math.round(row.getAveragedGap()), xAG, y);
        return this.context.fillText(" ms", xAG, y + this.fSmallFontHeight);
      }
    };

    StrikingDisplay.prototype.calcEffectivePixelsPerMs = function(row) {
      if (row.isHandstroke()) {
        return this.fEffectivePixelsPerMs = this.fPixelsPerMs * this.fAvBackDuration / (row.getRowDuration() - row.getAveragedGap() * row.getHandstrokeGap());
      } else {
        return this.fEffectivePixelsPerMs = this.fPixelsPerMs * this.fAvBackDuration / row.getRowDuration();
      }
    };

    StrikingDisplay.prototype.drawRowBackground = function(y, row, rowNumber, prevRow) {
      var delta, durPixels, h, rowBackground, rowStart;
      durPixels = Math.round((this.SPEED_WIDTH * (row.getRowDuration() - this.fMinDur)) / this.fMaxMinusMinDur);
      rowBackground = this.getRowColour(row, rowNumber);
      this.context.fillStyle = rowBackground;
      this.context.fillRect(this.fRowRight + this.fInterbellGap + 10, y - this.fHeightPerRow, durPixels, this.fHeightPerRow);
      this.context.fillRect(this.fRowLeft + this.fInterbellGap, y - this.fHeightPerRow, this.fRowRight - this.fRowLeft, this.fHeightPerRow);
      if (prevRow != null) {
        rowStart = row.getRowEndTime() - row.getRowDuration();
        delta = rowStart - prevRow.getRowEndTime();
        if (delta !== 0) {
          h = Math.round(this.fHeightPerRow * 0.25);
          delta *= this.fEffectivePixelsPerMs;
          if (delta > 0) {
            return this.context.fillRect(this.fRowLeft + this.fInterbellGap - delta, y - (h + this.fHeightPerRow) / 2, delta, h);
          } else {
            this.context.fillStyle = 'white';
            return this.context.fillRect(this.fRowLeft + this.fInterbellGap, y - (h + this.fHeightPerRow) / 2, -delta, h);
          }
        }
      }
    };

    StrikingDisplay.prototype.drawLines = function(y, row) {
      var b, j, _i, _j, _ref, _ref1, _results;
      for (j = _i = 0, _ref = row.getRowSize(); 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        this.fThisActualX[j] = this.strikeTimeToPixelX(row, row.getStrikeTime(j + 1));
        this.fThisCorrectX[j] = this.strikeTimeToPixelX(row, row.getCorrectStrikeTime(j + 1));
        b = row.getBellAt(j + 1);
        if (this.fLastActualX[j] > 0) {
          if ((j & 1) === 1) {
            this.drawLine(this.fLastCorrectX[j], y - this.fHeightPerRow * 3 / 2, this.fThisCorrectX[j], y - this.fHeightPerRow / 2, this.LIGHTGRAY);
          }
          if (!this.fInChangesOnly || this.fInChanges) {
            if (b === this.fHighlightedBell) {
              this.drawLine(this.fLastCorrectX[this.fLastPlace[b - 1]], y - this.fHeightPerRow * 3 / 2, this.fThisCorrectX[j], y - this.fHeightPerRow / 2, this.CORRECT_LINE_COLOUR);
            }
            this.drawLine(this.fLastActualX[this.fLastPlace[b - 1]], y - this.fHeightPerRow * 3 / 2, this.fThisActualX[j], y - this.fHeightPerRow / 2, this.GRID_COLOUR);
          }
        }
      }
      this.fInChanges = row.isInChanges();
      _results = [];
      for (j = _j = 0, _ref1 = row.getRowSize(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        b = row.getBellAt(j + 1);
        this.fLastPlace[b - 1] = j;
        this.fLastActualX[j] = this.fThisActualX[j];
        _results.push(this.fLastCorrectX[j] = this.fThisCorrectX[j]);
      }
      return _results;
    };

    StrikingDisplay.prototype.drawBellNumbers = function(y, row, rowNumber) {
      var b, j, s, x, xOff, _i, _ref, _results;
      y -= 5;
      xOff = -this.fCharWidth;
      _results = [];
      for (j = _i = 0, _ref = row.getRowSize(); 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        b = row.getBellAt(j + 1);
        x = this.strikeTimeToPixelX(row, row.getStrikeTime(j + 1));
        s = cas.BELL_CHARS.charAt(b - 1);
        this.context.fillStyle = 'black';
        _results.push(this.context.fillText(s, x + xOff, y));
      }
      return _results;
    };

    StrikingDisplay.prototype.strikeTimeToPixelX = function(row, strikeTime) {
      var t;
      t = row.getRowEndTime() - strikeTime;
      t *= this.fEffectivePixelsPerMs;
      return this.fRowRight - t;
    };

    StrikingDisplay.prototype.drawLine = function(startX, startY, endX, endY, colour) {
      var oldStyle;
      oldStyle = this.context.strokeStyle;
      this.context.strokeStyle = colour;
      this.context.beginPath();
      this.context.moveTo(startX, startY);
      this.context.lineTo(endX, endY);
      this.context.stroke();
      return this.context.strokeStyle = oldStyle;
    };

    StrikingDisplay.prototype.getRowColour = function(row, rowNumber) {
      if (row.isHandstroke()) {
        if (row.isGood()) {
          return this.BACKGROUND_HANDGOOD;
        } else if (row.isBad()) {
          return this.BACKGROUND_HANDBAD;
        } else {
          return this.BACKGROUND_HAND;
        }
      } else {
        if (row.isGood()) {
          return this.BACKGROUND_BACKGOOD;
        } else if (row.isBad()) {
          return this.BACKGROUND_BACKBAD;
        } else {
          return this.BACKGROUND_BACK;
        }
      }
    };

    return StrikingDisplay;

  })();

}).call(this);
