// Generated by CoffeeScript 1.7.1
(function() {
  cas.RowAccumulator = (function() {
    RowAccumulator.prototype.fNBells = 0;

    function RowAccumulator(pipeline) {
      this.fPipeline = pipeline;
      this.fData = [];
      this.fCurrentRow = new cas.RawRow(true);
      this.fNextRow = new cas.RawRow(false);
    }

    RowAccumulator.prototype.receiveBong = function(bong) {
      if (this.fNextRow.getRowSize() === 0) {
        if (this.fCurrentRow.isMatchingStroke(bong)) {
          if (this.fCurrentRow.findBell(bong.bell) > 0) {
            console.warn("WARNING: bell " + bong.bell + " sounded twice in row 1; ignoring second strike.");
          } else {
            this.fCurrentRow.addBong(bong);
          }
          return;
        }
      }
      if (this.fNextRow.isMatchingStroke(bong)) {
        if (this.fNextRow.findBell(bong.bell) > 0) {
          console.warn("WARNING: bell " + bong.bell + " sounded twice in row " + (this.fData.length + 2) + "; ignoring second strike.");
        } else {
          this.fNextRow.addBong(bong);
        }
        return;
      }
      this.finishRow();
      return this.fNextRow.addBong(bong);
    };

    RowAccumulator.prototype.finishRow = function() {
      this.fNBells = Math.max(this.fNBells, this.fCurrentRow.getNBells());
      this.fData.push(this.fCurrentRow);
      this.fCurrentRow = this.fNextRow;
      this.fNextRow = new cas.RawRow(!this.fCurrentRow.isHandstroke());
      return this.fPipeline.rowsAvailable(this.fData.length);
    };

    RowAccumulator.prototype.isSameStrokeBongs = function(b1, b2) {
      if (b1.stroke === cas.UNKNOWNSTROKE || b2.stroke === cas.UNKNOWNSTROKE) {
        return true;
      }
      return b1.stroke === b2.stroke;
    };

    RowAccumulator.prototype.isSameStrokeBongRow = function(bong, row) {
      if (bong.stroke === cas.UNKNOWNSTROKE) {
        return true;
      }
      if (bong.stroke === cas.HANDSTROKE) {
        return row.isHandstroke();
      }
      return !row.isHandstroke();
    };

    RowAccumulator.prototype.notifyInputComplete = function() {
      this.fData.push(this.fCurrentRow);
      if (!this.fNextRow.isHandstroke()) {
        this.fData.push(this.fNextRow);
      }
      this.fPipeline.rowsAvailable(this.fData.length);
      return this.fPipeline.notifyLastRowRung();
    };

    RowAccumulator.prototype.getNBells = function() {
      return this.fNBells;
    };

    RowAccumulator.prototype.size = function() {
      return this.fData.length;
    };

    RowAccumulator.prototype.getRow = function(i) {
      return this.fData[i];
    };

    return RowAccumulator;

  })();

}).call(this);
