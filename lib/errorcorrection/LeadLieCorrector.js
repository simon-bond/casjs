// Generated by CoffeeScript 1.7.1
(function() {
  cas.LeadLieCorrector = (function() {
    var LOG_OUTPUT;

    LOG_OUTPUT = false;

    LeadLieCorrector.prototype.fNBells = 0;

    LeadLieCorrector.prototype.fRowsProcessed = 0;

    function LeadLieCorrector() {
      this.fLastKnownGoodPositions = new Array(cas.MAXNBELLS);
    }

    LeadLieCorrector.prototype.receiveBong = function(bong) {
      var extra, firstRowLie, i, nextRowLie, place1, place2, placeInNext, split, _i, _j, _ref, _ref1;
      if (this.fRowsProcessed === 0) {
        if (this.fCurrentRow == null) {
          this.fCurrentRow = new cas.RawRow(bong.stroke === cas.HANDSTROKE);
          this.fNextRow = new cas.RawRow(bong.stroke !== cas.HANDSTROKE);
        }
        place1 = this.fCurrentRow.findBell(bong.bell);
        if (!this.fCurrentRow.isMatchingStroke(bong)) {
          this.fNextRow.addBong(bong);
          this.fRowsProcessed++;
        } else if (place1 < 0) {
          this.fCurrentRow.addBong(bong);
        } else {
          console.log("WARNING: bell " + bong.bell + " sounded twice in row " + this.fRowsProcessed + 1 + "; ignoring second strike.");
        }
        return;
      }
      this.fNBells = Math.max(this.fNBells, this.fCurrentRow.getNBells());
      if (this.fNextRow.isMatchingStroke(bong)) {
        place2 = this.fNextRow.findBell(bong.bell);
        if (place2 < 0) {
          this.fNextRow.addBong(bong);
        } else {
          this.finishRow();
          this.fNextRow.addBong(bong.swapStroke());
        }
        return;
      }
      if (this.fRowsProcessed < 2) {
        while (this.fCurrentRow.getRowSize() > 1) {
          firstRowLie = this.fCurrentRow.getLastBong();
          if (this.fNextRow.findBell(firstRowLie.bell) >= 0) {
            break;
          }
          this.fCurrentRow.removeLastBong();
          this.fNextRow.addBongAtLead(firstRowLie.swapStroke());
        }
        split = this.getCyclicSplit(this.fCurrentRow);
        if (split > 0) {
          if (split === this.getCyclicSplit(this.fNextRow)) {
            for (i = _i = split, _ref = this.fNextRow.getRowSize(); _i < _ref; i = _i += 1) {
              if (this.fNextRow.getBellAt(i + 1) === bong.bell) {
                this.finishRow();
                this.fNextRow.addBong(bong);
                return;
              }
            }
            extra = new cas.RawRow(!this.fNextRow.isHandstroke());
            for (i = _j = split, _ref1 = this.fNextRow.getRowSize(); _j < _ref1; i = _j += 1) {
              extra.addBongAtLead(this.fNextRow.removeLastBong().swapStroke());
              this.fNextRow.addBongAtLead(this.fCurrentRow.removeLastBong().swapStroke());
            }
            this.finishRow();
            this.fNextRow = extra;
            this.fNextRow.addBong(bong);
            return;
          }
        }
      } else {
        if (this.fCurrentRow.getRowSize() === this.fCurrentRow.getNBells()) {
          firstRowLie = this.fCurrentRow.getLastBong();
          if (bong.bell !== firstRowLie.bell && this.fLastKnownGoodPositions[firstRowLie.bell - 1] < this.fNBells / 3) {
            placeInNext = this.fNextRow.findBell(firstRowLie.bell);
            if (placeInNext === this.fNextRow.getRowSize()) {
              this.fCurrentRow.removeLastBong();
              nextRowLie = this.fNextRow.removeLastBong();
              this.fNextRow.addBongAtLead(firstRowLie.swapStroke());
              this.finishRow();
              this.fNextRow.addBong(nextRowLie.swapStroke());
              this.fNextRow.addBong(bong);
              return;
            }
            if (placeInNext < 0) {
              this.fCurrentRow.removeLastBong();
              this.fNextRow.addBongAtLead(firstRowLie.swapStroke());
              this.finishRow();
              this.fNextRow.addBong(bong);
              return;
            }
          }
        }
      }
      this.finishRow();
      return this.fNextRow.addBong(bong);
    };

    LeadLieCorrector.prototype.getCyclicSplit = function(row) {
      var b1, b2, bells, i, rotatedRow, split, _i, _j, _ref;
      rotatedRow = new cas.RawRow(row.isHandstroke());
      bells = row.fBells;
      i = 0;
      b1 = bells[i];
      split = 1;
      while (bells[i + 1] != null) {
        b2 = bells[i + 1];
        i++;
        if (b1.bell - b2.bell >= this.fNBells - 2) {
          break;
        }
        b1 = b2;
        split++;
      }
      if (split < row.getRowSize()) {
        for (i = _i = split, _ref = row.getRowSize(); _i < _ref; i = _i += 1) {
          rotatedRow.addBong(row.getBong(i + 1));
        }
        for (i = _j = 0; _j < split; i = _j += 1) {
          rotatedRow.addBong(row.getBong(i + 1));
        }
        if (rotatedRow.isCloseToRounds()) {
          return split;
        }
      }
      return -1;
    };

    LeadLieCorrector.prototype.finishRow = function() {
      var bong, _i, _len, _ref;
      if (LOG_OUTPUT) {
        console.log("LeadLieCorrector: " + fCurrentRow.rowAsString());
      }
      _ref = this.fCurrentRow;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bong = _ref[_i];
        this.fNextStage.receiveBong(bong);
        this.fLastKnownGoodPositions[bong.bell - 1] = this.fCurrentRow.findBell(bong.bell);
      }
      this.fCurrentRow = this.fNextRow;
      this.fNextRow = new cas.RawRow(!this.fCurrentRow.isHandstroke());
      return this.fRowsProcessed++;
    };

    LeadLieCorrector.prototype.notifyInputComplete = function() {
      this.finishRow();
      this.finishRow();
      return this.fNextStage.notifyInputComplete();
    };

    LeadLieCorrector.prototype.setNextStage = function(nextStage) {
      return this.fNextStage = nextStage;
    };

    return LeadLieCorrector;

  })();

}).call(this);
